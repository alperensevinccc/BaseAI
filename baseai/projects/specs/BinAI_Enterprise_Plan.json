{
  "projects/binai/__init__.py": "",
  "projects/binai/config/settings.py": "from __future__ import annotations\nfrom pydantic_settings import BaseSettings\n\nclass Settings(BaseSettings):\n    mode: str = \"mock\"  # mock|paper|live\n    symbol: str = \"BTCUSDT\"\n    atr_period: int = 14\n    vwap_window: int = 20\n    max_risk_per_trade: float = 0.01\n    kelly_cap: float = 0.5\n\nsettings = Settings()\n",
  "projects/binai/core/indicators.py": "from __future__ import annotations\nfrom collections.abc import Iterable\n\ndef _true_range(h: float, l: float, prev_close: float) -> float:\n    return max(h - l, abs(h - prev_close), abs(l - prev_close))\n\ndef atr(highs: Iterable[float], lows: Iterable[float], closes: Iterable[float], period: int = 14) -> list[float]:\n    h, l, c = list(highs), list(lows), list(closes)\n    if not (len(h) == len(l) == len(c)):\n        raise ValueError(\"length mismatch\")\n    if len(c) < period + 1:\n        return []\n    trs = [_true_range(h[i], l[i], c[i-1]) for i in range(1, len(c))]\n    # Wilder's RMA\n    rma = []\n    seed = sum(trs[:period]) / period\n    rma.append(seed)\n    alpha = 1 / period\n    for x in trs[period:]:\n        rma.append(rma[-1] + alpha * (x - rma[-1]))\n    return rma\n\ndef vwap(highs: Iterable[float], lows: Iterable[float], closes: Iterable[float], volumes: Iterable[float], window: int = 20) -> list[float]:\n    h,l,c,v = list(highs), list(lows), list(closes), list(volumes)\n    if not (len(h) == len(l) == len(c) == len(v)):\n        raise ValueError(\"length mismatch\")\n    out: list[float] = []\n    for i in range(len(c)):\n        s = max(0, i - window + 1)\n        pv = sum((h[j]+l[j]+c[j])/3 * v[j] for j in range(s, i+1))\n        vv = sum(v[j] for j in range(s, i+1)) or 1.0\n        out.append(pv / vv)\n    return out\n",
  "projects/binai/core/risk.py": "from __future__ import annotations\n\ndef kelly_fraction(win_rate: float, avg_win: float, avg_loss: float) -> float:\n    if avg_loss <= 0:\n        return 0.0\n    b = avg_win / avg_loss\n    return max(0.0, min(1.0, win_rate - (1 - win_rate) / b))\n\ndef position_size(balance: float, entry: float, stop: float, risk_per_trade: float, kelly_cap: float = 0.5) -> float:\n    if stop <= 0 or entry <= 0 or balance <= 0:\n        return 0.0\n    risk = balance * risk_per_trade\n    per_unit_risk = abs(entry - stop)\n    units = risk / per_unit_risk if per_unit_risk > 0 else 0.0\n    return max(0.0, units * kelly_cap)\n",
  "projects/binai/core/engine.py": "from __future__ import annotations\nfrom dataclasses import dataclass\nfrom .indicators import atr, vwap\n\n@dataclass\nclass Candle:\n    high: float\n    low: float\n    close: float\n    volume: float\n\nclass MockEngine:\n    def __init__(self, atr_period: int = 14, vwap_window: int = 20) -> None:\n        self.atr_period = atr_period\n        self.vwap_window = vwap_window\n\n    def process(self, candles: list[Candle]) -> dict:\n        if len(candles) < max(self.atr_period + 1, 2):\n            return {\"atr\": [], \"vwap\": []}\n        h = [c.high for c in candles]\n        l = [c.low for c in candles]\n        c = [c.close for c in candles]\n        v = [c.volume for c in candles]\n        return {\"atr\": atr(h,l,c, self.atr_period), \"vwap\": vwap(h,l,c,v, self.vwap_window)}\n",
  "projects/binai/adapters/binance_stub.py": "from __future__ import annotations\nfrom dataclasses import dataclass\n\n@dataclass\nclass Ticker:\n    symbol: str\n    price: float\n\nclass BinanceStub:\n    def price(self, symbol: str) -> Ticker:  # pragma: no cover\n        return Ticker(symbol, 50000.0)\n",
  "projects/binai/main.py": "from __future__ import annotations\nimport argparse\nfrom .core.engine import MockEngine, Candle\n\ndef run(mode: str) -> None:  # pragma: no cover (smoke via tests)\n    eng = MockEngine()\n    cs = [Candle(101, 99, 100, 10), Candle(102, 98, 101, 12)] * 20\n    out = eng.process(cs)\n    print({k: len(v) for k,v in out.items()})\n\nif __name__ == \"__main__\":\n    p = argparse.ArgumentParser()\n    p.add_argument(\"--mode\", default=\"mock\")\n    a = p.parse_args()\n    run(a.mode)\n",
  "projects/binai/tests/test_indicators.py": "from __future__ import annotations\nfrom projects.binai.core.indicators import atr, vwap\n\ndef test_atr_basic() -> None:\n    highs = [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]\n    lows  = [1,2,3,4,5,6,7,8, 9,10,11,12,13,14,15]\n    closes= [1.5,2.5,3.5,4.5,5.5,6.5,7.5,8.5,9.5,10.5,11.5,12.5,13.5,14.5,15.5]\n    out = atr(highs,lows,closes, period=14)\n    assert isinstance(out, list) and len(out) >= 1\n\ndef test_vwap_basic() -> None:\n    n=30\n    highs = [100+i*0.1 for i in range(n)]\n    lows  = [ 99+i*0.1 for i in range(n)]\n    closes= [ 99.5+i*0.1 for i in range(n)]\n    vols  = [ 10+i for i in range(n)]\n    out = vwap(highs,lows,closes,vols, window=20)\n    assert len(out) == n and out[-1] > out[0]\n",
  "projects/binai/tests/test_risk.py": "from __future__ import annotations\nfrom projects.binai.core.risk import kelly_fraction, position_size\n\ndef test_kelly_bounds() -> None:\n    k = kelly_fraction(0.55, 2.0, 1.0)\n    assert 0.0 <= k <= 1.0\n\ndef test_position_size_positive() -> None:\n    ps = position_size(10000.0, 100.0, 95.0, 0.01, 0.5)\n    assert ps > 0\n",
  "projects/binai/tests/test_engine_mock.py": "from __future__ import annotations\nfrom projects.binai.core.engine import MockEngine, Candle\n\ndef test_engine_outputs() -> None:\n    eng = MockEngine()\n    cs = [Candle(101, 99, 100, 10), Candle(103, 98, 101, 12)] * 20\n    out = eng.process(cs)\n    assert set(out.keys()) == {\"atr\",\"vwap\"}\n"
}
